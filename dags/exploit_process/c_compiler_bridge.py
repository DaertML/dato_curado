import subprocess
import os
import random
import re

class CCompilerBridge:
    """
    Acts as a wrapper for the gcc compiler and executes the resulting binary.
    
    This function compiles the provided C code and executes it to verify 
    that the LLM's proposed secure fix runs without compilation errors or runtime crashes.
    """

    def __init__(self, output_dir="/tmp/c_builds"):
        self.output_dir = output_dir
        os.makedirs(self.output_dir, exist_ok=True)
        print(f"C Compiler Bridge initialized. Build directory: {self.output_dir}")

    def test_secure_code_fix(self, c_code: str) -> bool:
        """
        Compiles the C code and executes it, checking the return status.
        
        Args:
            c_code: The secure C code proposed by the LLM.
        
        Returns:
            True if the code compiles successfully and executes with a zero return code, False otherwise.
        """
        
        if not c_code.strip():
            print("[COMPILER] ERROR: No code provided.")
            return False
            
        # Create a unique filename for the source and binary
        unique_id = os.urandom(8).hex()
        source_path = os.path.join(self.output_dir, f"code_{unique_id}.c")
        binary_path = os.path.join(self.output_dir, f"binary_{unique_id}")

        try:
            # 1. Write the C code to a temporary file
            with open(source_path, 'w') as f:
                f.write(c_code)
            
            # 2. Compile the code using gcc
            print(f"[COMPILER] Compiling source: {source_path}")
            compile_result = subprocess.run(
                ['gcc', source_path, '-o', binary_path, '-w'], # -w suppresses warnings
                capture_output=True, text=True, check=False, timeout=10
            )
            
            if compile_result.returncode != 0:
                print(f"[COMPILER] FAILED: Compilation error.\n{compile_result.stderr}")
                return False

            # 3. Execute the compiled binary
            print(f"[EXECUTOR] Running binary: {binary_path}")
            execute_result = subprocess.run(
                [binary_path],
                capture_output=True, text=True, check=False, timeout=10
            )

            if execute_result.returncode == 0:
                print(f"[EXECUTOR] SUCCESS: Code executed successfully (Exit Code 0).")
                # print(f"Output:\n{execute_result.stdout[:200]}...")
                return True
            else:
                # Non-zero exit code indicates a runtime error, crash, or segmentation fault
                print(f"[EXECUTOR] FAILED: Runtime error or crash (Exit Code {execute_result.returncode}).")
                # print(f"Output:\n{execute_result.stderr or execute_result.stdout}")
                return False

        except subprocess.TimeoutExpired:
            print("[EXECUTOR] FAILED: Execution timed out.")
            return False
        except Exception as e:
            print(f"[COMPILER/EXECUTOR] An unexpected error occurred: {e}")
            return False
            
        finally:
            # 4. Cleanup temporary files
            if os.path.exists(source_path):
                os.remove(source_path)
            if os.path.exists(binary_path):
                os.remove(binary_path)