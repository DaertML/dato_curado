import json
import os
import re
from c_compiler_bridge import CCompilerBridge
from security_llm_utils import check_security_fix

INPUT_FILE = "vulnerable_code.jsonl"
SECURE_FILE = "secure_results.jsonl"
FAILURE_FILE = "fix_failure_results.jsonl"

def load_jsonl_with_escape_fix(file_path):
    """
    Loads a JSONL file, attempting to fix common JSONDecodeErrors caused by 
    improperly escaped backslash and double-quote characters within the 
    embedded C code string, which often result in the 'Expecting , delimiter' error.
    """
    questions = []
    print(f"Attempting to load vulnerable code examples from {file_path}...")
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f, 1):
                clean_line = line.strip()
                if not clean_line:
                    continue

                # --- Two-step Parsing Attempt ---
                try:
                    # 1. Attempt normal load (Standard JSON)
                    data = json.loads(clean_line)
                    questions.append(data)
                
                except json.JSONDecodeError as e:
                    print(f"❌ Line {i}: Initial Error: {e}")
                    
                    # 2. If it fails, assume the error is due to unescaped quotes or backslashes
                    # This logic is kept to address the persistent parsing issue
                    try:
                        # Step 2a: Aggressive Backslash Fix (\\ -> \\\\)
                        line_with_bs_fix = clean_line.replace('\\', '\\\\') 

                        # Step 2b: Targeted Quote Fix
                        # Find the content of the "question" string value.
                        # This regex looks for "question": " followed by any characters (.+?) 
                        # up to the final closing quote. We use DOTALL to match newlines.
                        match = re.search(r'("question"\s*:\s*")(.+)"', line_with_bs_fix, re.DOTALL)
                        
                        if match and match.group(2):
                            # The content *inside* the string is match.group(2)
                            q_start_index = match.start(2)
                            q_content = match.group(2)
                            
                            # Now, escape all quotes inside this content (This fixes the "Expecting ," error)
                            q_content_fixed = q_content.replace('"', '\\"')
                            
                            # Reconstruct the line: start of line + fixed content + closing quote
                            # Note: The ending quote is still included in the original 'line_with_bs_fix' after the content
                            fixed_line = line_with_bs_fix[:q_start_index] + q_content_fixed + line_with_bs_fix[q_start_index + len(q_content):]
                            
                            # Final attempt to parse the doubly-fixed line
                            data = json.loads(fixed_line)
                            questions.append(data)
                            print(f"✅ Line {i}: Successfully loaded after fixing backslashes and quotes.")
                            
                        else:
                            # If targeted fix failed, try parsing the backslash-only fixed line as a last resort
                            data = json.loads(line_with_bs_fix)
                            questions.append(data)
                            print(f"✅ Line {i}: Successfully loaded after forcing backslash escapes.")
                            
                    except json.JSONDecodeError as fixed_e:
                        # If the fix caused a new error, we log the failure and skip the line.
                        print(f"❌ Line {i}: Failed to load even after fixing escapes. Final Error: {fixed_e}")
                        print(f"   Original line start: {clean_line[:100]}...")
                        
    except FileNotFoundError:
        print(f"Error: Input file '{file_path}' not found. Please ensure '{INPUT_FILE}' exists.")
        return []

    print(f"\nSuccessfully loaded {len(questions)} vulnerable code snippets.")
    return questions

def append_to_file(filepath: str, data: dict):
    """Appends a single JSON dictionary as a JSONL line to the specified file."""
    # Use 'a' mode for append
    with open(filepath, 'a') as f:
        f.write(json.dumps(data) + '\n')

def run_security_analysis_pipeline(input_filepath: str):
    """
    Main pipeline to process vulnerable C code, generate defensive fixes via LLM, 
    check the validity of the fixes, and save results.
    """
    
    # 1. Load vulnerable code snippets from JSONL file
    questions = load_jsonl_with_escape_fix(input_filepath)
    if not questions:
        print("No vulnerable code snippets loaded. Exiting.")
        return

    # 2. Initialize Compiler Bridge (Defensive Code Tester)
    compiler = CCompilerBridge()

    print(f"\nProcessing {len(questions)} security problems...")

    # 3. Process each vulnerable code snippet
    for i, question_data in enumerate(questions):
        print(f"\n===== Processing Vulnerability {i+1}/{len(questions)} =====")
        
        # Check if the 'question' key exists and contains the code
        if not 'question' in question_data:
            print(f"Skipping entry {i+1}: 'question' key is missing.")
            continue
            
        result = check_security_fix(compiler, question_data)
        
        # 4. Save results to the appropriate file
        if result['compiles_and_runs']:
            append_to_file(SECURE_FILE, result)
            print(f"\nFINAL VERDICT: FIX VERIFIED -> Result appended to {SECURE_FILE}")
        else:
            append_to_file(FAILURE_FILE, result)
            print(f"\nFINAL VERDICT: FIX FAILED VERIFICATION -> Result appended to {FAILURE_FILE}")
        
        print("-" * 50)

    print("\n\n--- SECURITY ANALYSIS PIPELINE FINISHED ---")
    print(f"Verified fixes saved to {SECURE_FILE}.")
    print(f"Unverified fixes saved to {FAILURE_FILE}.")
    
if __name__ == "__main__":
    # Ensure the output files are clean before starting
    if os.path.exists(SECURE_FILE): os.remove(SECURE_FILE)
    if os.path.exists(FAILURE_FILE): os.remove(FAILURE_FILE)
    
    # The input file is the one you provided in the context
    run_security_analysis_pipeline(INPUT_FILE)