{"question": "#include <stdio.h>\n#include <string.h>\n\n// 1. Stack Buffer Overflow (using strcpy on a fixed-size buffer)\nvoid vulnerable_function(const char* input) {\n    char buffer[16];\n    // WARNING: This strcpy operation does not check the size of 'input'\n    // If input is longer than 15 characters, it will overflow 'buffer'\n    // and potentially overwrite the return address on the stack.\n    strcpy(buffer, input);\n    printf("Processed: %s\n", buffer);\n}\n\nint main() {\n    // 32 characters, which is double the buffer size (16), guaranteeing overflow\n    const char* malicious_input = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";\n    printf("\n--- Running Example 1: Stack Buffer Overflow ---\n");\n    vulnerable_function(malicious_input);\n    printf("Execution continued (may crash in a real attack)\n");\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 2. Heap Buffer Overflow\nvoid process_data(const char* user_data) {\n    // Allocate exactly 10 bytes on the heap\n    char heap_buffer = (char)malloc(10);\n    if (!heap_buffer) return;\n\n    // WARNING: This memcpy copies 20 bytes into a 10-byte buffer (Heap Overflow)\n    // This corrupts adjacent heap metadata or other allocated blocks.\n    memcpy(heap_buffer, user_data, 20);\n    printf("Processed: %s\n", heap_buffer);\n\n    free(heap_buffer);\n}\n\nint main() {\n    printf("\n--- Running Example 2: Heap Buffer Overflow ---\n");\n    const char* input = "1234567890ABCDEFGHIJ"; // 20 bytes of data\n    process_data(input);\n    printf("Heap corruption occurred.\n");\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n\n// 3. Use After Free (UAF)\nint main() {\n    printf("\n--- Running Example 3: Use After Free ---\n");\n    \n    // 1. Allocate block A\n    int* ptr_a = (int*)malloc(sizeof(int));\n    if (!ptr_a) return 1;\n    ptr_a = 100;\n    printf("ptr_a allocated and set to %d\n", ptr_a);\n\n    // 2. Free block A\n    free(ptr_a);\n    printf("ptr_a free'd. Memory returned to allocator.\n");\n\n    // 3. Vulnerable point: Using the pointer 'ptr_a' after it has been freed\n    // The memory is now considered 'reusable' by the heap allocator.\n    // Attempting to read/write through 'ptr_a' is Undefined Behavior.\n    \n    // 4. Allocate block B (which might re-use the memory previously held by ptr_a)\n    int ptr_b = (int)malloc(sizeof(int));\n    if (!ptr_b) return 1;\n    ptr_b = 999;\n    printf("ptr_b allocated and set to %d\n", ptr_b);\n\n    // 5. Use After Free: If ptr_a and ptr_b share the same memory address,\n    // this line modifies the data of ptr_b, leading to corruption or unexpected behavior.\n    printf("\nUAF Operation: Re-reading through ptr_a...\n");\n    printf("Value at ptr_a (which is now ptr_b's memory): %d\n", ptr_a);\n    \n    free(ptr_b);\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <string.h>\n\n// 4. Stack Buffer Overflow (using gets)\nvoid input_handler() {\n    char buffer[10];\n    printf("Enter input: ");\n    // VULNERABLE FUNCTION: gets() reads input until a newline or EOF,\n    // with NO limit checking, making it trivial to overflow the buffer.\n    gets(buffer);\n    printf("Input received: %s\n", buffer);\n}\n\nint main() {\n    printf("\n--- Running Example 4: Stack Buffer Overflow (gets) ---\n");\n    // Note: Due to sandboxing, you cannot supply input dynamically here. \n    // In a real environment, any input > 9 bytes would trigger the overflow.\n    // For this demonstration, the vulnerability is in the call to gets().\n    // If this code were run directly, it would prompt for input until crash or return.\n    // input_handler(); \n    printf("The function 'gets' is the vulnerability here. Never use it.\n");\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n\n// 5. Double Free Vulnerability\nint main() {\n    printf("\n--- Running Example 5: Double Free ---\n");\n    // 1. Allocate a chunk of memory\n    void chunk = malloc(32);\n    if (!chunk) return 1;\n    printf("Chunk allocated at: %p\n", chunk);\n\n    // 2. First free (Correct)\n    free(chunk);\n    printf("First free successful.\n");\n\n    // 3. Second free (Vulnerable)\n    // WARNING: Calling free() on the same pointer twice is Undefined Behavior,\n    // often corrupting the heap metadata, which can be leveraged for attacks.\n    free(chunk);\n    printf("Second free called (Double Free vulnerability triggered).\n");\n\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n\n// 6. Integer Overflow leading to Buffer Overflow\n// In this scenario, we use a small size to demonstrate the concept of miscalculation.\nint main() {\n    printf("\n--- Running Example 6: Integer Overflow (Simulated) ---\n");\n    \n    // Imagine size_t total_size = num_elements * sizeof(int);\n    // where num_elements is an attacker-controlled input.\n    unsigned int num_elements = 0xFFFFFFFF; // Max 32-bit unsigned int\n    unsigned int element_size = 4; // sizeof(int)\n    \n    // If an attacker could input a size that causes total_size to wrap around\n    // to a small number, the allocation would be small, but the subsequent copy large.\n    \n    // In this specific example, let's skip the actual overflow and show the consequence\n    // of a failed size check.\n    int user_requested_size = 0x80000000; // Very large positive number\n    int allocated_size = 10;\n    \n    char buffer = (char)malloc(allocated_size);\n    if (!buffer) return 1;\n    \n    // VULNERABILITY: If 'user_requested_size' was the result of an overflow \n    // and is now small, but the actual amount of data to copy is huge,\n    // or vice versa (check passes, but allocation is tiny).\n    printf("Allocated size: %d bytes. User requested to handle %d bytes.\n", allocated_size, user_requested_size);\n    // If a check was: if (user_requested_size < allocated_size) then copy(user_requested_size)\n    // But the attacker causes an overflow making 'allocated_size' appear big and 'user_requested_size' small.\n    // We simulate the resulting overflow here:\n    strcpy(buffer, "A really long string that is much larger than 10 bytes");\n    printf("Simulated Overflow: %s\n", buffer);\n    \n    free(buffer);\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <string.h>\n\n// 7. Format String Vulnerability\nvoid log_message(const char user_input) {\n    printf("\nUser Log: ");\n    // VULNERABILITY: The user_input is passed directly as the format string.\n    // An attacker can use format specifiers (like %x, %s, %n) to leak memory or overwrite data.\n    printf(user_input);\n    printf("\n");\n}\n\nint main() {\n    printf("\n--- Running Example 7: Format String Vulnerability ---\n");\n    // A simple attack payload to read stack memory (often used for leaking addresses)\n    const char attack_payload = "Junk data %%x %%x %%x %%x";\n    log_message(attack_payload);\n    \n    // The payload "%%n" can be used to write arbitrary data to memory addresses.\n    // const char* write_payload = "AAAA%%n";\n    // log_message(write_payload);\n    \n    printf("The program printed arbitrary stack values due to the payload.\n");\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <string.h>\n\n// 8. Off-by-One Buffer Overflow\nint main() {\n    printf("\n--- Running Example 8: Off-by-One Buffer Overflow ---\n");\n    char buffer[10];\n    char marker = 'Z';\n    \n    // WARNING: The loop runs from i=0 to i<=10, which is 11 iterations (10 is the size).\n    // This writes 11 bytes into a 10-byte buffer, overwriting the byte immediately after 'buffer'.\n    int i;\n    for (i = 0; i <= 10; i++) {\n        buffer[i] = 'A'; // buffer[10] writes past the end of the array\n    }\n    \n    // If 'marker' is placed immediately after 'buffer' in memory, its value is corrupted.\n    printf("Buffer size: 10\n");\n    printf("Marker value (before/after overflow): %c / %c\n", 'Z', marker);\n    \n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 9. Heap Buffer Overflow with realloc\nvoid realloc_vulnerability(int new_size) {\n    char p = (char)malloc(10);\n    if (!p) return;\n    strcpy(p, "123456789"); // 9 characters + null terminator\n    \n    // WARNING: realloc might expand the block in place but we still write too much\n    char p_new = (char)realloc(p, new_size); // New size is 10\n    if (!p_new) { free(p); return; }\n    p = p_new;\n\n    // VULNERABLE: We allocate 10 bytes (new_size) but copy a much larger string.\n    // Even if realloc moves the block, the copy size is unchecked.\n    const char* data_to_copy = "This data is way too long for a 10 byte buffer";\n    strcpy(p, data_to_copy);\n    printf("Processed: %s\n", p);\n\n    free(p);\n}\n\nint main() {\n    printf("\n--- Running Example 9: Heap Buffer Overflow (realloc) ---\n");\n    realloc_vulnerability(10);\n    printf("Heap corruption possible from uncontrolled strcpy after realloc.\n");\n    return 0;\n}\n"}
{"question": "#include <stdio.h>\n#include <stdlib.h>\n\n// 10. Use After Free (with object type confusion)\nstruct User {\n    char name[16];\n    void (auth_func)();\n};\n\nvoid default_auth() {\n    printf("\n[!] Default authentication failed.\n");\n}\n\nvoid grant_admin_access() {\n    printf("\n[!!!] ADMIN ACCESS GRANTED!\n");\n}\n\nint main() {\n    printf("\n--- Running Example 10: UAF (Type Confusion) ---\n");\n    \n    // 1. Allocate User object A\n    struct User user_a = (struct User*)malloc(sizeof(struct User));\n    if (!user_a) return 1;\n    user_a->auth_func = default_auth;\n    printf("User A created with default auth_func: %p\n", user_a->auth_func);\n\n    // 2. Free User object A\n    free(user_a);\n    printf("User A free'd.\n");\n    \n    // 3. Allocate a different object (or attacker-controlled data) that re-uses the same memory location\n    // This attacker's 'fake object' data overwrites the memory where user_a->auth_func used to be.\n    void* fake_data = malloc(sizeof(struct User));\n    // Attacker crafts the fake data to contain the address of the privileged function\n    // (The address of grant_admin_access is written into the location of the auth_func pointer)\n    if (fake_data) {\n        ((void*)(fake_data + 16)) = grant_admin_access; // Offset 16 is where auth_func resides\n        printf("Fake object allocated, overwriting function pointer with %p\n", grant_admin_access);\n    }\n\n    // 4. Use After Free (Type Confusion Attack)\n    // The program still holds the 'user_a' pointer, which now points to the 'fake_data' content.\n    // Calling user_a->auth_func() executes the attacker's supplied function pointer.\n    printf("\nUAF Attack: Calling the function pointer via the stale user_a pointer...\n");\n    user_a->auth_func(); \n    \n    free(fake_data);\n    return 0;\n}\n"}
